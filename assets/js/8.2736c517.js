(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{211:function(n,t,e){"use strict";e.r(t);var a=e(0),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"第三课-指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三课-指针"}},[n._v("#")]),n._v(" 第三课 指针")]),n._v(" "),e("h2",{attrs:{id:"一-指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-指针"}},[n._v("#")]),n._v(" 一 指针")]),n._v(" "),e("h3",{attrs:{id:"_1-什么是指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是指针"}},[n._v("#")]),n._v(" 1 什么是指针")]),n._v(" "),e("blockquote",[e("p",[n._v("指针其实就是一个变量，不过它的值是一个内存地址 ， 这个地址可以是变量或者一个函数的地址")]),n._v(" "),e("p",[n._v("当你声明明一个变量的时候，计算机会将指定的一块内存空间和变量名进行绑定；这个定义很简单，但其实很抽象，例如：int x = 5; 这是一句最简单的变量赋值语句了， 我们常说“x等于5”，其实这种说法是错误的，x仅仅是变量的一个名字而已，它本身不等于任何值的。这条statement的正确翻译应该是：“将5赋值于名字叫做x的内存空间”，其本质是将值5赋值到一块内存空间，而这个内存空间名叫做x。切记：x只是简单的一个别名而已，x不等于任何值。")])]),n._v(" "),e("ul",[e("li",[n._v("为什么需要指针?")])]),n._v(" "),e("blockquote",[e("p",[n._v("实际上是可以的，但是并不是所有的情况都可以。比如：")]),n._v(" "),e("ol",[e("li",[n._v("在内部函数中，可以使用指针访问外部函数中定义的某个变量x, 因为它并不是声明在自己的函数范围内。")]),n._v(" "),e("li",[n._v("指针在处理函数传递数组的时候非常高效")]),n._v(" "),e("li",[n._v("我们还可以在堆中申请一块动态内存，这块内存甚至没有一个变量名称，唯一的访问方式是通过指针。")]),n._v(" "),e("li",[n._v("可以使用你指针访问指定的内存地址（游戏修改器）")])])]),n._v(" "),e("h3",{attrs:{id:"_2-指针使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-指针使用"}},[n._v("#")]),n._v(" 2 指针使用")]),n._v(" "),e("h4",{attrs:{id:"a-声明指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-声明指针"}},[n._v("#")]),n._v(" a 声明指针")]),n._v(" "),e("blockquote",[e("ol",[e("li",[n._v("声明指针的时候要记得初始化，如果没有初始化，指针存放的将会是垃圾数据(因为你根本不知道它指向何方)")]),n._v(" "),e("li",[n._v("可以使用nullptr（c++11）进行指针初始化，初始化存放的值是 0")])])]),n._v(" "),e("h4",{attrs:{id:"b-初始化指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-初始化指针"}},[n._v("#")]),n._v(" b 初始化指针")]),n._v(" "),e("h4",{attrs:{id:"c-指针地址和大小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-指针地址和大小"}},[n._v("#")]),n._v(" c 指针地址和大小")]),n._v(" "),e("blockquote",[e("p",[n._v("指针实际上也是一个变量，也会有自己的内存空间，也会有自己的长度大小。获取指针的内存地址，依然使用取地址符 "),e("code",[n._v("&")]),n._v(" ， 长度大小依然使用"),e("code",[n._v("sizeof")]),n._v(" 来获取")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\n//指针的单词是pointer　所以声明指针，通常会带上一个字母p\nint main() {\n   \n    string name = "zhangsan";\n\n    //age 变量名称 , int修饰的是数据类型．\n    int age =10 ;\n\n    //指针里面放的是地址，　int修饰的是这个指针指向的数据类型．\n    //指针前面的类型和指向的数据类型必须一致\n    int *a  = &age;\n\n    //声明一个指针\n    int * p_age=nullptr;\n\n    //初始化，给指针赋值，让指针指向age\n    p_age = &age;\n\n    //\n    cout << "age的数据是：" << age << endl;\n    cout << "age的地址是：" << &age << endl;  // 0x7ffdc0d0c3bc\n    cout << "age的占用空间大小是：" << sizeof(age) << endl;  // 4\n    cout << "char的占用空间大小是：" << sizeof(char) << endl;  // 1\n    cout << "double的占用空间大小是：" << sizeof(double) << endl;  // 1\n    \n    cout << "p_age的数据是：" << p_age << endl;  //0x7ffdc0d0c3bc\n    cout << "p_age的地址是：" << &p_age << endl;\n    cout << "p_age的占用空间大小是：" << sizeof(p_age) << endl;  // 8   32位系统是4  ，64为系统是8\n    cout << "char指针的占用空间大小是：" << sizeof(char*) << endl;  // 8\n    cout << "double指针的占用空间大小是：" << sizeof(double*) << endl;  // 8\n\n    // \n    cout << "p_age指向的数据是：" << *p_age << endl;\n\n    return 0;\n}\n')])])]),e("h3",{attrs:{id:"_3-指针dereference（-解引用）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-指针dereference（-解引用）"}},[n._v("#")]),n._v(" 3 指针dereference（ 解引用）")]),n._v(" "),e("blockquote",[e("p",[n._v("所谓的指针dereference就是，指针就是一个变量，存放的是一个地址。这个地址有可能是变量 a 或者是变量b的地址。有了这个地址，我们可以通过"),e("strong",[n._v("dereference")]),n._v("操作符 "),e("code",[n._v("*")]),n._v(" 去获取到a对应的值或者b对应的值。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nint main() {\n\n    int age = 10 ;\n\n    int *p_age = &age;  //这里的 * 仅仅使用标识这个p_age是一个指针\n\n    //1. 直接使用变量age获取数据\n    cout << "使用变量获取 age = " << age << endl; // 10\n    age = 88;\n    cout << "使用变量获取 age = " << age << endl; // 88\n\n    //2. 使用指针来获取数据  这里的*表示解引用。\n    cout << "使用指针获取age = " << *p_age << endl; // 88\n    *p_age = 99 ;\n    cout << "使用指针获取age = " << *p_age << endl; // 99\n\n\n    //3.指针在声明的时候必须初始化。!!!!!!\n     //指针声明然后没有初始化，是很危险的．因为它会指向随机的区域，如果未来使用这个指针修改了指向区域的数据\n     //有可能这个区域是其他程序申请的内存空间　．\n    int *p1 = 0; // 没有任何指向。 这个指针存放的数据是0. 如果有指向，存放的数据是内存地址（16进制）\n    int *p2 = NULL; //空指针 ，也是没有指向\n    int *p3 = nullptr; //建议使用这种 。 空指针 ，也就是没有指向 ，会报 nullpointerexception  空指针异常\n\n    cout << "p1的数据是：" << p1 << endl; // 0\n    cout << "p2的数据是：" << p2 << endl; // 0\n    cout << "p3的数据是：" << p3 << endl; // 0\n\n    //如果指针是空指针，是不能使用解引用的。有异常。\n    cout << "p1指向的数据是：" << *p1 << endl;\n    cout << "p2指向的数据是：" << *p2 << endl;\n    cout << "p3指向的数据是：" << *p3 << endl;\n\n    return 0;\n}\n')])])]),e("h3",{attrs:{id:"_4-动态内存分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-动态内存分配"}},[n._v("#")]),n._v(" 4 动态内存分配")]),n._v(" "),e("blockquote",[e("p",[n._v("在进行编码的时候，我们根本不知道需要多少内存空间。举个例子，比如我们需要存储学生的数据，这时候可以使用数组来存储，那么就必须知道学生的具体人数。如果不知道，就无法使用数组了。实际上之前学过的vector就是使用动态内存。但是有时候，我们如果需要存放的是一单个对象数据，并不是一堆数据。用vector就有点浪费了。")]),n._v(" "),e("p",[n._v("为了解决上述问题，C++ 提供了一种“动态内存分配”机制，使得程序可以在运行期间，根据实际需要，要求操作系统临时分配一片内存空间用于存放数据。此种内存分配是在程序运行中进行的，而不是在编译时就确定的，因此称为“动态内存分配”。申请动态内存")])]),n._v(" "),e("h4",{attrs:{id:"a-申请内存-和-释放内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-申请内存-和-释放内存"}},[n._v("#")]),n._v(" a 申请内存 和 释放内存")]),n._v(" "),e("blockquote",[e("p",[n._v("可以使用"),e("code",[n._v("new")]),n._v(" 关键字来申请动态内存 ， "),e("code",[n._v("new")]),n._v(" 开辟出来的空间都位于堆内存中。")]),n._v(" "),e("p",[e("code",[n._v("new")]),n._v(" 常和 "),e("code",[n._v("delete")]),n._v(" 成对出现，使用 "),e("code",[n._v("new")]),n._v(" 开辟空间， 使用 "),e("code",[n._v("delete")]),n._v(" 释放申请的内存，避免造成内存泄漏。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid run(){\n\n    int number  = 200;\n\n}\n\nint main() {\n\n    run(); //只要这行代码执行完毕，里面的number占用的空间，即被释放．\n\n    int age= 10;  //存放在栈\n    cout << "age = " << age <<endl;\n\n    \n    //1. new关键字用于在堆内存中开辟空间，然后返回的是这块空间的内存地址。\n    //思考一个问题：为什么new返回的是一个地址呢？　 因为开辟的内存没有明确的标识与之绑定\n    //为了以后能够操作这块内存，所以直接返回的是地址．\n    int *age2 = new int(20); //存放在堆内存  // ---- C 库函数 void *malloc(size_t size) 分配所需的内存空间，并返回一个指向它的指针。\n    cout << "age2 = " << *age2 <<endl;\n\n\n    //2.　释放内存  不要进行多次释放\n    delete age2; // ---- C 库函数 void free(void *ptr) 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间\n    age2 = nullptr ; // 表示这个指针没有任何指向．\n\n\n    return 0;\n}\n')])])]),e("h4",{attrs:{id:"b-数组操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-数组操作"}},[n._v("#")]),n._v(" b 数组操作")]),n._v(" "),e("blockquote",[e("p",[n._v("使用"),e("code",[n._v("new int[]")]),n._v(" 来给数组申请动态内存 , 然后使用 "),e("code",[n._v("delete[]")]),n._v(" 释放申请的内存")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct stu{\n\n};\n\nint main() {\n\n    int *age = new int(10);\n    delete age;  //如果删除普通的数据申请的内存，　delete  - delete xx\n\n\n    //开辟了堆内存\n    int *scores = new int[10]{55,66,77,88,99,1,2,3,4,5};\n   /* for (int i = 0; i < 10; ++i) {\n        scores[i] = 90 +i;\n    }\n*/\n    for (int i = 0; i < 10; ++i) {\n       cout << "scores =" <<scores[i] << endl;\n    }\n\n    //只有在删除申请的数组内存，才需要跟上　[]  delete[]xxx\n    delete []scores;\n\n\n\n    //结构体\n    stu *s  = new stu();\n    delete s;\n\n    return 0;\n}\n')])])]),e("h4",{attrs:{id:"c-关于动态内存的思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-关于动态内存的思考"}},[n._v("#")]),n._v(" c 关于动态内存的思考")]),n._v(" "),e("blockquote",[e("p",[n._v("通常情况下，定义的变量存储的位置位于栈内存中，栈内存的数据，当函数执行结束后即会被释放，这是栈内存的机制自己决定的，并且栈内存中由于内存并不是太大，所以不建议大量的数据存放在栈内存。")]),n._v(" "),e("p",[n._v("而堆内存中的容量相比栈内存要大多了，但是堆内存并不提供回收释放的工作，允许程序申请内存空间，但是同时也要自己负责内存空间的释放工作。")]),n._v(" "),e("p",[n._v("不能一概而论哪一种是最优的决定，要根据开发场景来决定。")])]),n._v(" "),e("h3",{attrs:{id:"_5-数组和指针的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-数组和指针的关系"}},[n._v("#")]),n._v(" 5 数组和指针的关系")]),n._v(" "),e("blockquote",[e("p",[n._v("数组其实和指针是存在一些内在联系的，如下：")]),n._v(" "),e("ol",[e("li",[n._v("根据数组名字取到的内存地址，是数组的第一个元素地址")]),n._v(" "),e("li",[n._v("指针其实是一个变量，这个变量存放的值是内存地址")]),n._v(" "),e("li",[n._v("如果一个指针和数组是同样的类型，并且指针存放的地址正好是数组的某个元素地址，那么可以通过该指针操作数组")])])]),n._v(" "),e("h4",{attrs:{id:"a-数组与指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-数组与指针"}},[n._v("#")]),n._v(" a 数组与指针")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include<iostream>\nusing namespace std;\n\nint main(){\n    \n    //定义3个长度的int类型数组\n    int scores []{100, 95 , 98};\n\n    //直接打印数组，实际上是打印数组第一个元素的地址   0x61fec8\n    cout << scores  << endl;  \n    \n    //使用*操作符是根据地址获取数据，所以取到的是第一个元素 ： 100\n    cout << *scores  << endl; \n\n     //声明指针，存放的是数组第一个元素的地址\n    int *score_ptr{scores};  \n    \n    //打印指针，其实输出它保存的地址，即数组首元素地址 0x61fec8\n    cout << score_ptr  << endl;  \n    \n    //解引用，输出的是数组的首元素 100\n    cout << *score_ptr  << endl; \n    \n    return 0 ;\n}\n")])])]),e("h4",{attrs:{id:"b-指针运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-指针运算"}},[n._v("#")]),n._v(" b 指针运算")]),n._v(" "),e("blockquote",[e("p",[n._v("如果指针指向的是数组的第一个元素地址，那么同样可以通过对指针进行加减运算，来获取其他的元素 。值得注意的是，指针的相加并不是单纯数字上的相加，而是指针对应类型占用字节的相加")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\nusing namespace std;\nint main(){\n\n    //定义3个长度的int类型数组\n    int scores []{100, 95 , 98};\n\n    //定义一个int类型指针，指向的是数组的首元素\n    int *score_ptr{scores};\n    // int *score_ptr = &scores[0];\n\n    //使用数组的手法打印数组\n    cout << score_ptr[0]  << endl; //100\n    cout << score_ptr[1] << endl; //95\n    cout << score_ptr[2] << endl; //98\n\n////////////////////////////////////////////////////////////\n\n    //取地址\n    cout << "第1个元素的地址： " << &scores[0] << endl; // 0x7ffd1f7f0310\n    cout << "第2个元素的地址： " << &scores[1] << endl; // 0x7ffd1f7f0314\n    cout << "第3个元素的地址： " << &scores[2] << endl; // 0x7ffd1f7f0318\n\n    //打印数组\n    cout << "第1个元素： " << *&scores[0] << endl; // 100\n    cout << "第2个元素： " << *&scores[1] << endl; // 95\n    cout << "第3个元素： " << *&scores[2] << endl; // 98\n\n////////////////////////////////////////////////////////////\n\n    //对指针进行加法运算。由于score_ptr 是int类型，\n    //而int类型占用4个字节，所以每次相加打印出来的地址都会变长4个字节\n    cout <<score_ptr  << endl; // 0x7ffd1f7f0310\n    cout <<(score_ptr+1)  << endl; // 0x7ffd1f7f0314\n    cout <<(score_ptr +2) << endl; // 0x7ffd1f7f0318\n\n    //指针解引用取值\n    cout <<*score_ptr  << endl; // 100\n    cout <<*(score_ptr+1)  << endl; // 95\n    cout <<*(score_ptr +2) << endl; // 98\n\n    //可以使用指针对数组进行修改值\n    scores[2] = 199;\n    cout << "数组的第3个元素是：" << *(score_ptr+2) <<endl;\n    *(score_ptr+2) = 200;\n    cout << "数组的第3个元素是：" << *(score_ptr+2) <<endl;\n\n    //先对score_ptr进行解引用，然后 +1\n    cout <<"*score_ptr+1 =" <<  *score_ptr+1 << endl;\n\n    //先对score_ptr+1 然后解引用。\n    cout <<"*(score_ptr+1) = " <<  *(score_ptr+1) << endl;\n\n    //这是指向最后的元素\n    int *p_last = &scores[2];\n\n    //如果根据这个p_last  取第1元素。\n    cout << "第1个元素是：" <<  *( p_last-2 )<< endl;\n\n    return 0 ;\n}\n')])])]),e("h3",{attrs:{id:"_6-指针算数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-指针算数"}},[n._v("#")]),n._v(" 6 指针算数")]),n._v(" "),e("blockquote",[e("p",[n._v("指针除了表示存储的是内存地址之外，它也可以做算术运算 和 比较大小。")]),n._v(" "),e("p",[n._v("指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。")])]),n._v(" "),e("h4",{attrs:{id:"a-指针递增"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-指针递增"}},[n._v("#")]),n._v(" a 指针递增")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("score_ptr++\n")])])]),e("h4",{attrs:{id:"b-指针递减"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-指针递减"}},[n._v("#")]),n._v(" b 指针递减")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("score_ptr--\n")])])]),e("h4",{attrs:{id:"c-等价判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-等价判断"}},[n._v("#")]),n._v(" c 等价判断")]),n._v(" "),e("blockquote",[e("p",[n._v("两个指针的等价判断，实际上是他们指向的地址比较")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("cout<<(score_ptr == p_last)<<endl; // true\n")])])]),e("h3",{attrs:{id:"_7-指针与常量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-指针与常量"}},[n._v("#")]),n._v(" 7 指针与常量")]),n._v(" "),e("p",[n._v("a 指针常量")]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("const int *p")]),n._v(" 表示指针指向常量 ， 不允许修改对应的值，但是可以指向别的地方， 这和常量修改值一样。")])]),n._v(" "),e("p",[n._v("b 常量指针")]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("int* const p")]),n._v(" 表示这个指针是常量指针，不能再指向别的地方了，但是可以修改目前指向地方的值")])]),n._v(" "),e("p",[n._v("c 常量指针指向常量")]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("const int* const p")]),n._v(" 表示这个指针是常量指针，并且它指向的位置的值也是常量")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\n    int newage = 18;\n    \n    //1. 指向常量的指针，（指针常量）  const int *p\n    //指针常量是修饰数据，让指针以为那份数据是一份常量数据，不允许修改。其实是可以修改。使用变量age就可以修改。\n    int age = 10;\n\n    //要想区分这些，很简单。从中间的*开始左右两边分开。\n    //*的右边，表示指针\n    //*的左边，表示指针指向的数据。\n    const int * p_age = &age;  //但是这个数据并不一定的是常量数据，只是让指针有一种错觉，以为它真的是常量\n\n    //能不能修改指向吗？ 可以修改指向\n    //p_age = &newage;\n\n    //能不能根据指针修改数据吗？ 不允许修改指向位置的值。\n    //*p_age = 88;\n\n\n    //2. 常量指针。  int * const p\n\n    int a = 10 ;\n    int b = 20;\n\n    int * const p2 = &a;\n\n    //能修改目前指向的值吗？ 可以修改指向位置的值\n//    *p2 = 88;\n\n    //能修改指向吗？ 不能修改指向。\n//    p2 = &b;\n\n\n    //3. 常量指针指向常量\n\n    int c = 3;\n    int d = 4;\n\n    const int * const pc = &c;\n\n    //能修改指向位置的值吗？不能\n//    *pc = 33;\n\n    //能修改新的指向吗？不能\n//    pc = &d;\n\n   return 0;\n}\n")])])]),e("h2",{attrs:{id:"二-指针与函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-指针与函数"}},[n._v("#")]),n._v(" 二 指针与函数")]),n._v(" "),e("h3",{attrs:{id:"_1-参数传递指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-参数传递指针"}},[n._v("#")]),n._v(" 1 参数传递指针")]),n._v(" "),e("blockquote",[e("p",[n._v("函数的参数，除了传递普通的变量，引用之外，还可以把指针当成参数来传递")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid changeVal(int * number);\n\nint main() {\n\n    int age = 10;\n\n    //该函数负责修改数值\n    changeVal(&age);\n    \n    cout << "age =" << age <<endl;\n\n    return 0;\n}\n\nvoid changeVal(int * number){\n//    *number = *number * 2;\n\n    //第一个* 表示解引用 ，第二个* 表示乘法运算\n    *number *= 2;\n}\n')])])]),e("blockquote",[e("p",[n._v("在某些情况下，传递指针比其他方式的传递要合适得多，比如下面有一个函数负责交换传递进来的两个参数的值， 此时如果不使用指针或者引用，则无法实现该功能")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid swap(int *a , int *b);\n\nint main() {\n\n\n    int a = 3 ;\n    int b = 4 ;\n\n    //使用函数来交换数据\n    swap( &a , &b);\n\n    cout << "a = " << a  << " , b= " << b << endl;\n\n\n    return 0;\n}\n\nvoid swap(int *a , int *b){\n\n    int *temp = a;  //temp 和  a是一样的\n    a = b;  // a 存的是b的地址。\n    b = temp ;   //b 存放的是a的地址\n\n\n   /* int *temp = a;  //把a的地址给temp . temp 和 a 都指向一块共同的地方，这个地方的数据是3.\n    *a = *b;  // 把a指向的那个地方的数据修改成  4.\n    *b = *temp; // 把temp的数据赋值给b .  temp的数据是4.*/\n    /*\n    int temp = *a ;\n    *a = *b ;\n    *b = temp;*/\n}\n\n')])])]),e("h3",{attrs:{id:"_2-函数返回指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数返回指针"}},[n._v("#")]),n._v(" 2 函数返回指针")]),n._v(" "),e("blockquote",[e("p",[n._v("函数平常除了返回标准的数值之外，其实也可以返回指针。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint * calc_max(int * a , int  * b);\n\n\nint main() {\n\n    int x = 10;\n    int y = 20;\n\n    int *p = calc_max(&x, &y);\n\n    cout << "最大值： " << *p << endl;\n\n    return 0;\n}\n\nint * calc_max(int * a , int  * b){\n\n    return *a > *b ? a : b;\n\n    /*if(*a > *b){\n        return a;\n    }\n\n    return b;*/\n}\n\n\n')])])]),e("blockquote",[e("p",[e("strong",[n._v("注意")]),n._v("： 不要返回局部变量的引用或者指针 ， 因为本地变量的声明周期应该只位于函数内部。一旦函数执行完毕则被释放。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint* getAge2(){\n\n    int age = 66;\n    return &age; \n}\n \n//不推荐\nint& getAge(){\n\n    int age = 66;\n    int &a = age;\n    return a;\n}\n\nint main() {\n    \n    cout << getAge() << endl;\n    return 0;\n}\n")])])]),e("h3",{attrs:{id:"_3-二级指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-二级指针"}},[n._v("#")]),n._v(" 3 二级指针")]),n._v(" "),e("blockquote",[e("p",[n._v("指向指针的指针，即可称之为二级指针。有点类似二维数组，数组里面装的是数组，即可称之为二维数组。")]),n._v(" "),e("p",[n._v("二级指针不如一级指针使用的那么频繁，通常出现的地方是作为函数参数传递。如果在函数的内部想要修改外部一级指针指向的数据值，那么则需要二级指针了。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid create_pointer(int **p1){\n    //二级指针解引用，会得到一级指针，其实就是得到了外面的 p\n    *p1 = new int(10);\n}\n\nint main() {\n\n//    int age = 10 ;\n//    int *p1 = &age;  // 一级指针\n//    int **p2 = &p1;  //二级指针\n//\n//    cout << "age的值是：" << age << endl;\n//    cout << "age的值是：" << *p1 << endl;\n//    cout << "age的值是：" << **p2 << endl;\n\t\n    int *p = nullptr;\n\n    //让p指向堆内存中的一块空间，这块空间里面存放的数据是 10.\n    //函数的参数在传递的时候，执行的是，值的拷贝。\n    create_pointer(&p);\n\n    //指针没有任何指向，是空指针，解引用会出错\n    cout << "p指向的数据是：" << *p << endl;\n    //释放内存\n    delete p ;\n    return 0;\n}\n\n')])])]),e("h3",{attrs:{id:"_4-函数指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-函数指针"}},[n._v("#")]),n._v(" 4 函数指针")]),n._v(" "),e("h4",{attrs:{id:"a-基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-基本使用"}},[n._v("#")]),n._v(" a 基本使用")]),n._v(" "),e("blockquote",[e("p",[n._v("函数指针的意思是指向函数的指针 。 通常来说，指针是变量，有自己的类型，那么函数指针也有类型。只不过它的类型稍微不一样而已。函数指针的类型由函数的返回值、函数的参数列表决定。 要想声明一个函数指针，只需要使用"),e("code",[n._v("指针")]),n._v("来替换"),e("code",[n._v("函数名")]),n._v("即可。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\nusing namespace std;\n\n//函数原型\nint add(int a , int b); \n\nint main(){\n    \n    //前半段表示声明一个函数指针add_ptr  该函数指针指向的函数返回值是int，并且有两个int类型的参数。\n    //指针的小括号不能省略。\n    int (*add_ptr) (int,int) =add;\n    \n    //普通方式调用函数\n    int result =add(3,4);\n    cout << "result = " << result << endl;\n    \n    //使用函数指针方式调用add函数\n    int result2 = add_ptr(3,4) ;\n    cout << "result2 = " << result2 << endl;\n    \n    return 0 ;\n}\n\nint add(int a , int b){\n    return a + b;\n}\n')])])]),e("h4",{attrs:{id:"b-函数指针作为参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-函数指针作为参数"}},[n._v("#")]),n._v(" b 函数指针作为参数")]),n._v(" "),e("blockquote",[e("p",[n._v("有时候，也可以把某个函数A通过参数的方式传递给另一个函数B，随后在函数B里面执行传递进来的函数A。")]),n._v(" "),e("p",[n._v("函数虽然不能直接作为参数来进行传递，但是函数指针可以。实际上在传递的时候，传递的是指针而已。")]),n._v(" "),e("p",[n._v("比如下面的示例： 有一个计算的函数"),e("code",[n._v("calc")]),n._v(" , 允许在第三个参数传递进来具体的计算函数。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include<iostream>\nusing namespace std;\n\nint add (int a , int b)；\nint calc(int a , int b ,int (*fun)(int, int))；\n\nint main() {\n    //函数指针p，指向add函数\n    //int(*p)(int ,int) = add;\n    //cout << calc(3,5 , p) << endl;\n    \n    //函数名称可以直接使用，它实际上就是一个函数指针。\n    cout << calc(3,5 , add) << endl;\n    return 0 ;\n}\nint add (int a , int b){\n    return a + b;\n}\n\n//计算的函数，最后的参数要求的是一个函数指针。\nint calc(int a , int b ,int (*fun)(int, int)){\n    return fun(a,b);\n}\n")])])]),e("h4",{attrs:{id:"c-函数指针的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-函数指针的作用"}},[n._v("#")]),n._v(" c 函数指针的作用")]),n._v(" "),e("blockquote",[e("p",[n._v("如果一个通用的函数，需要使用到 另一个函数，但是这个函数并没有确定名称，是由其他组织或者个人开发的，那么这时候可以预留一个位置，做成函数指针 虚位以待。比如：现在有一个vector或者数组，需要交给其他个人或组织来遍历，但是这些组织或者个人的遍历手法不一样，那么这时候可以使用函数指针占位。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\n")])])]),e("h4",{attrs:{id:"d-typedef使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#d-typedef使用"}},[n._v("#")]),n._v(" d typedef使用")])])}),[],!1,null,null,null);t.default=s.exports}}]);