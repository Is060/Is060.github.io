(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{212:function(a,t,e){"use strict";e.r(t);var n=e(0),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"cpp的小细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpp的小细节"}},[a._v("#")]),a._v(" CPP的小细节")]),a._v(" "),e("h2",{attrs:{id:"小细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小细节"}},[a._v("#")]),a._v(" 小细节")]),a._v(" "),e("h3",{attrs:{id:"１-数组和指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#１-数组和指针"}},[a._v("#")]),a._v(" １　数组和指针")]),a._v(" "),e("p",[a._v("数组在定义的时候是数组，传递给其他变量或者参数的时候，是指针")]),a._v(" "),e("h3",{attrs:{id:"２-大小端模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#２-大小端模式"}},[a._v("#")]),a._v(" ２　大小端模式")]),a._v(" "),e("p",[a._v("大端模式(big-endian)，数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中。数据转换慢。")]),a._v(" "),e("p",[a._v("小端模式(little-endian)，数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。数据转换快。")]),a._v(" "),e("blockquote",[e("p",[a._v("下面以unsigned int value = 0x12345678为例")])]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",[a._v("内存地址")]),a._v(" "),e("th",[a._v("little-endian存放内容")]),a._v(" "),e("th",[a._v("big-endian存放内容")])])]),a._v(" "),e("tbody",[e("tr",[e("td",[a._v("0x4000")]),a._v(" "),e("td",[a._v("0x78")]),a._v(" "),e("td",[a._v("0x12")])]),a._v(" "),e("tr",[e("td",[a._v("0x4001")]),a._v(" "),e("td",[a._v("0x56")]),a._v(" "),e("td",[a._v("0x34")])]),a._v(" "),e("tr",[e("td",[a._v("0x4002")]),a._v(" "),e("td",[a._v("0x34")]),a._v(" "),e("td",[a._v("0x56")])]),a._v(" "),e("tr",[e("td",[a._v("0x4003")]),a._v(" "),e("td",[a._v("0x12")]),a._v(" "),e("td",[a._v("0x78")])])])]),a._v(" "),e("h3",{attrs:{id:"３-struct的对齐原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#３-struct的对齐原则"}},[a._v("#")]),a._v(" ３　struct的对齐原则")]),a._v(" "),e("p",[a._v("原则一："),e("strong",[a._v("结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定")]),a._v("会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。")]),a._v(" "),e("p",[a._v("原则二："),e("strong",[a._v("在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。")])]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\nusing namespace std;\nstruct X{\n    char a;\n    int b;\n    double c;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;// 结果 1６\n}\n// 从０开始，ａ占用０，空１－３，ｂ占用４－７，ｃ占用８－１５\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\nusing namespace std;\nstruct X{\n    char a;\n    double c;\n    int b;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;// 结果　24\n}\n// 从０开始，ａ占用０，空１－７，ｃ占用８－１５，ｂ占用１６－１９，空２０－２３\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\nusing namespace std;\nstruct X{\n    double c;\n    char a;\n    int b;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;// 结果　16\n}\n// 从０开始 c占用0-7，a占用８，空９－１１，ｂ占用１２－１５\n")])])]),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\nusing namespace std;\nstruct X{\n    double c;\n    char a;\n    int b;\n    char d;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;// 结果　24\n}\n// 从０开始，ｃ占用０－７，ａ占用８，空９－１１，ｂ占用１２－１５，ｄ占用１６，空１７－２３\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\n\nusing namespace std;\nstruct X{\n    double c;\n    char a;\n    int b;\n    char d;\n    int e;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;//　结果　24　\n}\n// 从０开始，ｃ占用０－７，ａ占用８，空９－１１，ｂ占用１２－１５，ｄ占用１６，空１７－１９，ｅ占用２０－２３\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\n\nusing namespace std;\nstruct X{\n    int e;\n    double c;\n    char a;\n    int b;\n    char d;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl; // 结果　32\n}\n// 从０开始，ｅ占用０－３，空４－７，ｃ占用８－１５，ａ占１６，空１７－１９，ｂ占用２０－２３，ｄ占用２４，空２５－３１\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\n\nusing namespace std;\nint temp = 1;\nstruct point{\n    int * p = &temp;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;\n    cout<< sizeof(point)<<endl; // 结果　８\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("#include <iostream>\n\nusing namespace std;\nstruct X{\n    char a;\n    int b;\n    double c;\n};\nstruct Y{\n    char a;\n    X b;\n};\nint main(int argc, char *argv[]) {\n    cout<< sizeof(X)<<endl;// 16\n    cout<< sizeof(Y)<<endl;// 24\n}\n// 以Ｘ中最长元素为占位数，不是以sizeof(X)为占位数\n")])])]),e("h3",{attrs:{id:"４-struct、union和enum"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#４-struct、union和enum"}},[a._v("#")]),a._v(" ４　struct、union和enum")]),a._v(" "),e("h4",{attrs:{id:"struct"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#struct"}},[a._v("#")]),a._v(" struct")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("struct structure_name {\nmember_type1 member_name1;\nmember_type2 member_name2;\nmember_type3 member_name3;\n.\n.\n} object_names;\n// struct是一组数据元素一个名字，这些数据元素，作为成员，可以有不同类型和不同长度\n")])])]),e("h4",{attrs:{id:"union"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[a._v("#")]),a._v(" union")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("union union_name {\n  member_type1 member_name1;\n  member_type2 member_name2;\n  member_type3 member_name3;\n  .\n  .\n} object_names;\n")])])]),e("blockquote",[e("p",[a._v("union，内部只能是结构体（struct）和普通变量类型（如int等），共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员，共用体占用的内存等于最长的成员占用的内存，共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。")])]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("union data{\n    int n;\n    char ch;\n    double f;\n};\nunion data a, b, c;\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("union data{\n    int n;\n    char ch;\n    double f;\n} a, b, c;\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("union{\n    int n;\n    char ch;\n    double f;\n} a, b, c;\n")])])]),e("h4",{attrs:{id:"enum"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#enum"}},[a._v("#")]),a._v(" enum")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("enum enumeration_name {\n  value1,\n  value2,\n  value3,\n  .\n  .\n} object_names;\n")])])]),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("enum Week {SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY};\n")])])]),e("blockquote",[e("p",[a._v("其中SUNDAY = 0,MONDAY = 1……SATURDAY = 6。也就是说，第１个枚举值代表0，第2个枚举值代表1，这样依次递增1。")])]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" enum Week {MONDAY = 1,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY};\n")])])]),e("blockquote",[e("p",[a._v("其中MONDAY等于1，这样，TUESDAY就将等于2，直接到SUNDAY等于7。")])]),a._v(" "),e("h3",{attrs:{id:"５-error-call-of-overloaded-‘abs-double-’-is-ambiguous"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#５-error-call-of-overloaded-‘abs-double-’-is-ambiguous"}},[a._v("#")]),a._v(" ５　error: call of overloaded ‘abs(double&)’ is ambiguous")]),a._v(" "),e("p",[a._v("在C语言中，除了abs()函数存在于"),e("code",[a._v("<stdlib.h>")]),a._v("，其它数学函数都存在于"),e("code",[a._v("<math.h>")])]),a._v(" "),e("p",[a._v("在C++中"),e("code",[a._v("<cmath>")]),a._v("定义了abs()函数,可以对浮点数进行操作，"),e("code",[a._v("<cstdlib>")]),a._v("定义了abs()函数只能对整型操作。fabs()函数存在于"),e("code",[a._v("<cmath>")]),a._v("。")]),a._v(" "),e("h3",{attrs:{id:"６-lambda-函数与表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#６-lambda-函数与表达式"}},[a._v("#")]),a._v(" ６　Lambda 函数与表达式")]),a._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[capture](parameters)->return-type{body}\n")])])]),e("blockquote",[e("p",[a._v("[]      // 沒有定义任何变量。使用未定义变量会引发错误。\n[x, &y] // x以传值方式传入（默认），y以引用方式传入。\n[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。\n[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。")])]),a._v(" "),e("blockquote",[e("p",[a._v("对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入")]),a._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[this]() { this->someFunc(); }();\n")])])])]),a._v(" "),e("h3",{attrs:{id:"７-cmake-cxx-flags"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#７-cmake-cxx-flags"}},[a._v("#")]),a._v(" ７　  "),e("code",[a._v("CMAKE_CXX_FLAGS")])]),a._v(" "),e("p",[a._v("在cmake脚本中，设置编译选项可c以通过"),e("code",[a._v("add_compile_options")]),a._v("命令，也可以通过set命令修改"),e("code",[a._v("CMAKE_CXX_FLAGS")]),a._v("或"),e("code",[a._v("CMAKE_C_FLAGS")]),a._v("。")])])}),[],!1,null,null,null);t.default=s.exports}}]);