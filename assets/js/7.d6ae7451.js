(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{209:function(n,t,e){"use strict";e.r(t);var s=e(0),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"第二课-vector和函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二课-vector和函数"}},[n._v("#")]),n._v(" 第二课 vector和函数")]),n._v(" "),e("h2",{attrs:{id:"一-vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-vector"}},[n._v("#")]),n._v(" 一 Vector")]),n._v(" "),e("blockquote",[e("p",[n._v("vector其实很大程度上和数组一样，只是，数组是固定长度，而vector是不定长度（动态增长）。")]),n._v(" "),e("p",[n._v("vector 在C++STL(标准模板库)中的一个容器，可以看成是对容器的一种扩展。在运行时可以改变长度 , 与数组具有相似的语法 , 相比数组更高效 , 提供越界检查")])]),n._v(" "),e("h3",{attrs:{id:"_1-声明和初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-声明和初始化"}},[n._v("#")]),n._v(" 1 声明和初始化")]),n._v(" "),e("blockquote",[e("p",[n._v("使用vector除了要导入"),e("code",[n._v("#include <vecotr>")]),n._v("之外，由于它声明于std命名空间里面，所以要配合std命名空间使用")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\n    //ｖｅｃｔｏｒ是一个容器，里面只能装同一种的数据类型．\n    int scores[6];\n\n    // 1. 仅仅是声明而已。   \n    // 假设声明了10个空间，要放入15个空间的数据，则在新的地方挖出来15个空间的位置，然后把10个空间的数据拷贝过去。对系统表示，这原来这10个空间的内存可以被回收了。\n    vector<int> v(1);\n\n    //2. 往里面赋值\n    v.push_back(10);\n    v.push_back(20);\n\n    //3. 声明并初始化\n    vector<string> ss{"aa","bb","cc"};\n    \n    return 0;\n}\n')])])]),e("h3",{attrs:{id:"_2-访问vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-访问vector"}},[n._v("#")]),n._v(" 2 访问vector")]),n._v(" "),e("blockquote",[e("p",[n._v("访问 "),e("code",[n._v("vector")]),n._v("中的元素有两种方式，一是仍以数组的方式，另一种是使用"),e("code",[n._v("vector")]),n._v("提供的"),e("code",[n._v("at")]),n._v("函数")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\n    vector<int> scores{80,90,95,100,88};\n\n    //1. 以数组的方式取值  //这种方式不会进行边界越界检查\n    cout << scores[0] << " = " << scores[1] << " = "<< scores[2] << " = "<< scores[3]<< " = "<< scores[4]<<endl;\n\n    //也可以使用下标的方式赋值\n    scores[0] = 66;\n    scores[1] = 77 ;\n\n    //2. 以vector本身提供的方式取值 //会进行越界检查\n    cout <<\n        scores.at(0) << " = " <<\n        scores.at(1) << " = "<<\n        scores.at(2) << " = "<<\n        scores.at(3)<< " = "<<\n        scores.at(4)<<endl;\n\n    return 0;\n}\n')])])]),e("h3",{attrs:{id:"_3-操作vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-操作vector"}},[n._v("#")]),n._v(" 3 操作vector")]),n._v(" "),e("h4",{attrs:{id:"a-一维vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-一维vector"}},[n._v("#")]),n._v(" a 一维vector")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\n    vector<int> scores{77,88,99,100,85 , 78};\n\n   /* //1. 可以往里面追加元素\n    scores.push_back(66);\n    scores.push_back(79);\n\n\n    //2. 查看vector的数据\n    for (int i = 0; i < scores.size(); ++i) {\n        cout << "分数=" << scores.at(i) << endl;\n    }\n\n    for(int s : scores){\n        cout << "分数2=" << s << endl;\n    }\n*/\n\n    return 0;\n}\n')])])]),e("h4",{attrs:{id:"b-二维vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-二维vector"}},[n._v("#")]),n._v(" b 二维vector")]),n._v(" "),e("blockquote",[e("p",[n._v("二维vector和二维数组实际上差不太多，二维数组是数组里面装的是数组，二维vector指的是vector里面装的还是vector，在未来碰到矩阵相关的存储操作，多半使用vector来作为媒介")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\n/*\n    //1. 定义整个最外层的容器\n    vector<vector<int>> scores;\n\n    //2. 定义3个班的容器\n    vector<int> scores1 {100,89,80,78,90};\n    vector<int> scores2{100,89,80,78,90};\n    vector<int> scores3{100,89,80,78,90};\n\n    //3. 把3个班的成绩装到外层容器里面去。\n    scores.push_back(scores1);\n    scores.push_back(scores2);\n    scores.push_back(scores3);*/\n\n\n    //一步到位的写法：\n    vector<vector<int>> newscores{\n            {100,89,80,78,90},\n            {88,36,79,78,50},\n            {65,76,67,34,90}\n    };\n\n/*\n    //遍历\n    for(int i = 0 ; i < newscores.size() ; i++){\n        for(int j = 0 ; j< newscores[i].size(); j++){\n//            cout << " " << newscores[i][j];\n            cout << " " << newscores.at(i).at(j);\n        }\n        cout << endl;\n    }*/\n\n\n//    vector< vector<int>  > newscores\n    for(vector<int> vectors : newscores){\n        for(int score :vectors){\n            cout << " " << score;\n        }\n        cout << endl;\n    }\n\n    cout << "----------------------------------------" << endl;\n\n    for(auto vectors : newscores){\n        for(auto score :vectors){\n            cout << "1= " << score;\n        }\n        cout << endl;\n    }\n    return 0;\n}\n')])])]),e("h2",{attrs:{id:"二-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-函数"}},[n._v("#")]),n._v(" 二 函数")]),n._v(" "),e("h3",{attrs:{id:"_1-定义函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义函数"}},[n._v("#")]),n._v(" 1 定义函数")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\n/*函数返回值  函数名称  函数参数{\n    函数体\n    return xxx;\n};*/\n\n//1. 没有参数，没有返回值\nvoid sayHi(){\n    cout << "早上好" <<endl;\n}\n\n//2. 有参数，没有返回值\nvoid sayHi02(string name){ // string name = "张三"\n    cout << name << " , 早上好" << endl;\n}\n\n//3. 无参数，有返回值\nstring sayHi03(){\n    return "李四，早上好" ;\n}\n\n//4. 有参数，有返回值\nstring sayHi04(string name){\n    return name + " , 晚上好";\n}\n\nint main() {\n    sayHi();\n    sayHi02("张三");\n\n    //获取函数的返回值\n    string result = sayHi03(); //string result = "李四，早上好";\n    cout << result << endl;\n    \n    string result02 = sayHi04("王五");\n    cout << result02 << endl;\n    return 0;\n}\n')])])]),e("h3",{attrs:{id:"_2-函数原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数原型"}},[n._v("#")]),n._v(" 2 函数原型")]),n._v(" "),e("blockquote",[e("p",[n._v("一般来说，c++的函数一般包含声明和定义两个部分。因为c++是静态类型语言，程序属于自上而下编译，所以在使用函数前，必须先表示函数的存在，告诉编译器函数所需要的参数以及函数的返回值是什么")]),n._v(" "),e("p",[n._v("把函数分成声明和定义两部分，函数的原型定义在调用的前面，具体实现可以放在后面")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <string>\n\nusing namespace std;\n\n//函数的原型， 也叫做声明函数，并不知道这个函数具体是如何实现的。只是有一些基本架子而已\nvoid run();\n\n//有一个函数，名字叫做add, 有两个参数，都是int类型，有返回值 是 int类型\nint add(int a , int b);\n\nint main() {\n    \n   run();\n    \n   int result =  add(3,4);\n\n    return 0;\n}\n\nint add(int a , int b){\n    return a + b;\n}\n\n//定义函数 ，函数的真正实现\nvoid run(){\n    cout << "学生在跑步" <<endl;\n}\n')])])]),e("h3",{attrs:{id:"_3-分离式编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-分离式编译"}},[n._v("#")]),n._v(" 3 分离式编译")]),n._v(" "),e("blockquote",[e("p",[n._v("一般说来，函数的声明 ( 函数原型 )通常都会放到头文件中，之所以称之为头文件是因为它总是在main函数的前面就引入进来。头文件一般以 .h 或者 .hpp 结尾，通常用于 写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现")])]),n._v(" "),e("p",[n._v("math.h")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/*\n * 这三句话用于解决头文件被重复include的问题\n */\n\n#ifndef DAY02_MATH_H   //if no define 如果定义了这个标记，标记的名称来源： _工程的名字_头文件的名字_H  为了区分唯一性。\n#define DAY02_MATH_H  //则定义这个标记\n//函数声明\nint add (int a , int b);\n#endif //DAY02_HEADER_H  //结束判断\n")])])]),e("p",[n._v("math.cpp")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include "math.h"\n\n//函数定义 ，函数的真正实现。\nint add(int a , int b){\n    return a + b ; \n}\n')])])]),e("p",[n._v("main.cpp")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>  \n#include "math.h" \n// include的时候 <>用于导入编译环境提供的文件。 如果要导入自己定义的文件，使用""\n// "" 会先在当前的工程查找这个文件，如果这个文件不存在，则会到提供的系统(即gcc编译环境去找)里面去找。\nint main(){\n    add(1 ,2);\n    return 0 ;\n}\n')])])]),e("p",[n._v("CMakeLists.txt")]),n._v(" "),e("div",{staticClass:"language-cmake extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cmake"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("cmake_minimum_required")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token property"}},[n._v("VERSION")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("3.14")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("project")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("day02"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token variable"}},[n._v("CMAKE_CXX_STANDARD")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("14")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[n._v('#  main.cpp 使用 #include "math.cpp" 的话')]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[n._v("# add_executable(09_function_header  09_function_header.cpp)")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[n._v('# main.cpp 使用 #include "math.h" 的话，则需要表示还有哪些文件要编译，否则math.cpp这个源文件不会被编译')]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("add_executable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("09_function_header  09_function_header.cpp math.cpp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n")])])]),e("h3",{attrs:{id:"_4-函数重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-函数重载"}},[n._v("#")]),n._v(" 4 函数重载")]),n._v(" "),e("blockquote",[e("p",[n._v("在许多语言中，经常会见到两个或者两个以上的函数名称是一样的，当然他们的 "),e("strong",[n._v("参数个数")]),n._v(" 或者 "),e("strong",[n._v("参数类型")]),n._v(" 或者是 "),e("strong",[n._v("参数的顺序")]),n._v(" 是不一样的。这种现象有一个学名叫做 "),e("strong",[n._v("重载")]),n._v(" overload， 由于python属于动态类型语言，不区分数据类型，参数可以是任意类型，所以它没有重载。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include <iostream>\nusing namespace std;\n/*\n *\n * 重载的函数，调用的时候，会根据实际参数的个数、类型来决定究竟执行哪一个函数。\n *\n *  重载的特征是什么：\n *      1. 具有相同的函数名\n *      2. 参数个数不同 ,参数类型不同， 参数的顺序不同。\n */\n\nvoid a(int x , char y){\n\n}\n\nvoid a(char y , int x){\n\n}\n\nint add(int a , int b){\n    return a + b;\n}\n\nint add(int a , int b, int c){\n    return a + b + c;\n}\n\nint add(double a , double b){\n    return a + b;\n}\n\nint main(){\n\n    add(3,4);\n\n    add(1,2,3);\n\n    add(4.5 ,1.5);\n    \n    cout << add(1,2) << endl;\n    cout << add(1,2 , 3) << endl;\n    cout << add(1.5,2.5) << endl;\n\n    return 0 ;\n}\n")])])]),e("h3",{attrs:{id:"_5-函数参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-函数参数"}},[n._v("#")]),n._v(" 5 函数参数")]),n._v(" "),e("blockquote",[e("p",[n._v("python的函数，在传递参数的时候，有可变对象和不可变对象的现象，那么在C++里面也有类似的说法。只不过是另一种说辞罢了。")]),n._v(" "),e("p",[n._v("python中传递不可变对象，在C++中，对应的是值的拷贝，也就是传递的只是数据的一份拷贝而已。在函数内部修改数据，并不会改变外部数据")]),n._v(" "),e("p",[n._v("python中传递可变对象，在c++中，对应的是引用传递，也就是传递的是对象的引用，而不是拷贝。在函数内部修改数据，会导致外部数据也发生改变。")])]),n._v(" "),e("h4",{attrs:{id:"a-值拷贝传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-值拷贝传递"}},[n._v("#")]),n._v(" a 值拷贝传递")]),n._v(" "),e("blockquote",[e("p",[n._v("C++默认情况下，处理函数参数传递时，多数使用的是值的拷贝，少数部分除外。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\nusing namespace std;\n\nint sccle_max(int number){  // int number  = 105;\n\n    if(number > 100){\n        number = 100;\n    }\n    return number ;\n}\n\nvoid a(int x){ //int x= 105;\n    x = 0;\n}\n\nint main(){\n\t//这里传递进去105. 但是只是执行了数据的拷贝，函数内部不管改成多少，外部的这个number还是105\n    int number = 105 ;\n    cout <<  sccle_max(number) << endl;\n    cout << "number  =" << number << endl;\n    \n    //这里传递进去105. 但是只是执行了数据的拷贝，函数内部不管改成多少，外部的这个number还是105\n    a(number);\n    cout << "number2  =" << number << endl;\n\n    return 0 ;\n}\n')])])]),e("h4",{attrs:{id:"b-传递数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-传递数组"}},[n._v("#")]),n._v(" b 传递数组")]),n._v(" "),e("blockquote",[e("p",[n._v("函数的参数除了能传递普通简单的数据之外，数组也是可以传递的。但是数组稍微有点特殊，这里多做讲解。")]),n._v(" "),e("ol",[e("li",[n._v("前面提过，形参实际上就是实参的一份拷贝，就是一个局部变量。")]),n._v(" "),e("li",[n._v("数组的数据太大，如果都进行拷贝，那么比较麻烦，也造成了浪费")]),n._v(" "),e("li",[n._v("所以实际上传递数组的时候，并不会进行整个数组的拷贝，而只是传递数组的第一个元素内存地址 （指针 ） 进来。")]),n._v(" "),e("li",[n._v("数组的数据还是在内存中，只是把第一个元素（也就是数组的起始）内存地址传进来而已。")]),n._v(" "),e("li",[n._v("这就造成了函数的内部根本无法知道这个数组的元素有多少个。")])])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\nusing namespace std;\n\n// 数组是一串连续性的地址存放的数据，而且数组是一个容器。\n// 这里传递的时候，传递的是数组的第一个元素的内存地址。（指针 =  内存地址）\nvoid printArray(int scores[]){\n    scores[3] = 77;\n\n}\n\nvoid printArray2(int scores[]){\n\n    cout << "scores.sizeof = " << sizeof(scores) << endl; // 内存地址，大小为8\n    cout << "int.sizeof = " << sizeof(int) << endl; // int数据，大小为4\n\n    for(int i = 0 ; i < sizeof(scores) / sizeof(int) ; i++){\n        cout << " " << scores[i]; // 打印结果： 70 80\n    }\n}\n\nvoid printArray3(int scores[] , int length) {\n\n    for(int i = 0 ; i < length ; i++){\n        cout << " " << scores[i];\n    }\n\n    //数组不支持使用范围for循环遍历。 迭代器。\n    /*for(int s : scores){\n\n    }*/\n}\n\n\nint main(){\n\n    int scores[]{70,80,90,100,88};\n\n    scores[3] = 66;\n    cout << "第四个元素：" << scores[3] << endl; // 66\n\n    printArray(scores);\n    cout << "第四个元素：" << scores[3] << endl; // 77\n\t\n    printArray2(scores);\n    \n\tcout << "main:: scores.sizeof = " << sizeof(scores) << endl; // 20\n    cout << "main:: int.sizeof = " << sizeof(int) << endl; // 4\n    printArray3(scores , sizeof(scores) / sizeof(int)); // 打印结果： 70 80 90 77 88\n\n    return 0 ;\n}\n')])])]),e("h4",{attrs:{id:"c-传递引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-传递引用"}},[n._v("#")]),n._v(" c 传递引用")]),n._v(" "),e("blockquote",[e("p",[n._v("目前为止，我们所有函数的参数传递，都是对数据进行了一份拷贝（数组除外）。那么在函数的内部是不能修改值的，因为这仅仅是一份值得拷贝而已（函数外部的值并不会受到影响）。如果真的想在函数内部修改值，那么除了数组之外，还有一种方式就是传递"),e("code",[n._v("引用")]),n._v("。")]),n._v(" "),e("p",[n._v("引用实际上只是原有数据的一种别名称呼而已，使用 "),e("code",[n._v("&")]),n._v(" 定义")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\nusing namespace std;\n\n/*\n *\n * 传值的方式，会拷贝，消耗内存，效率有点低， 安全。\n *\n * 传递引用的方式，不会拷贝，不管函数外部还是函数内部，使用的都是同一份数据，不消耗内存，效率高一点，可以修改数据，不安全\n *  如果以后函数的内部期望修改外部的数据，那么可以使用引用的方式传递数据，除了之外还可以使用指针的方式。\n\n */\n\nvoid changeValue(int & a){  //表示传递进来一个int类型数据的引用\n    a = 0 ;\n}\n\nint main(){\n\n    int age = 33;\n    changeValue(age);\n    cout << age << endl;// 0\n\n    int a = 6;\n    int b = a ;\n    a = 7 ;\n\n    cout << "a = " << a << "  b = " << b << endl; // a = 7  b = 6\n\n    int c = 8;  // c是一个体\n    int &d = c; // d 只是 c 的一个别名而已。 操作d等同于操作C。  引用相当于外号。\n\n    d = 99 ;\n    cout << "c = " << c << "  d = " << d << endl; // c = 99  d = 99\n    \n    return 0 ;\n}\n')])])]),e("h4",{attrs:{id:"d-传递vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#d-传递vector"}},[n._v("#")]),n._v(" d 传递vector")]),n._v(" "),e("blockquote",[e("p",[n._v("vector和普通的数据一样，传递的时候，做的是值的拷贝。数据有点浪费，只想传递引用，怎么办呢？")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid printVector( vector<int> &scores);\nvoid printVector2( vector<int> &scores);\n\nint main(){\n\n    int a = 3 ;\n\n    vector<int> scores{60,80,70,90,100};\n\n    printVector(scores);\n    cout << " 0 = " << scores[0] << endl; // 60\n\n    printVector2(scores);\n    cout << " 0 = " << scores[0] << endl; // 99\n    return 0 ;\n}\n\nvoid printVector( vector<int>  &scores){  //这里确实是传递引用\n\n    //遍历每一个元素\n        for(int s : scores){ //发生了一次拷贝。\n            //如果发现了60, 就把60 改成99;\n            if(s == 60){  //这里修改的仅仅是 变量s的值，不是scores这个容器的第0个位置。\n                s = 99 ;\n            }\n        }\n}\n\nvoid printVector2( vector<int>  &scores){  \n\n    //遍历每一个元素\n    for(int &s : scores){ // 传递引用\n        \n        if(s == 60){  \n            s = 99 ;\n        }\n    }\n}\n')])])]),e("h3",{attrs:{id:"_6-函数是如何被调用工作的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-函数是如何被调用工作的"}},[n._v("#")]),n._v(" 6 函数是如何被调用工作的")]),n._v(" "),e("blockquote",[e("ol",[e("li",[n._v("函数是使用函数调用栈，来管理函数调用工作的\na. 类似盒子的栈\nb. 遵循后进先出\nc. 可以往里面执行压栈和出栈动作（push 和 pop）")]),n._v(" "),e("li",[n._v("栈的结构和激活记录\na. 函数必须把它的返回值返回给调用它的函数(A ---\x3e B)\nb. 每次函数的调用都需要创建一次激活记录，然后把它压入栈中(push)\nc. 当一个函数被调用完毕的时候，就需要从栈中弹出（pop）\nd. 函数的参数以及内部的局部变量都是存储在栈中。")]),n._v(" "),e("li",[n._v("函数栈有可能抛出栈溢出异常（Stack Overflow）\na. 一旦函数调用栈中被push进来的函数记录过多，就有可能出现。（例如：无限循环调用）")])])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include <iostream>\n\nusing namespace std;\n\nvoid func2(int &x , int y , int z){\n    x += y+z;\n}\n\nint func1(int a , int b){\n    int result{};\n    result += a + b;\n    func2(result , a , b );\n\n    // func1( result , a); // 会导致无限循环\n    return result ;\n}\n\nint main (){\n    int x{10};\n    int y{20};\n    int z{};\n\n    z = func1(x , y );\n    \n    cout << z << endl; // 60\n    return 0 ;\n}\n")])])]),e("h3",{attrs:{id:"_7-内联函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-内联函数"}},[n._v("#")]),n._v(" 7  内联函数")]),n._v(" "),e("blockquote",[e("p",[n._v("函数可以使我们复用代码，但是一个函数的执行，需要开辟空间、形参和实参进行值得拷贝，还要指明函数返回、以及最后回收释放资源的动作，这个过程是要消耗时间的。")]),n._v(" "),e("p",[n._v("增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。")]),n._v(" "),e("p",[n._v("有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include <iostream>\n\nusing namespace std;\n\n//函数作为一个 个体存在，能够鲜明的表示这段代码的用意\ninline int add(int a ,int b){\n    return a + b;\n}\n\nint main (){\n\n\n    int x = 3 ;\n    int y = 4;\n\n    int result = add(x  ,y) ;\n  \n    cout << result << endl;\n\n    return 0 ;\n}\n\n")])])]),e("h3",{attrs:{id:"_8-范围规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-范围规则"}},[n._v("#")]),n._v(" 8 范围规则")]),n._v(" "),e("blockquote",[e("p",[n._v("在学习过程，我们会定义很多变量或者引用，这些变量由于定义的位置不同，所以它们的作用域范围也不同。一般会划分成几种类型： "),e("code",[n._v("代码块")]),n._v(" | "),e("code",[n._v("局部变量")]),n._v(" | "),e("code",[n._v("静态变量")]),n._v(" | "),e("code",[n._v("全局变量")])])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <iostream>\n\nusing namespace std;\n\nint number = 99 ;  // 全局变量\n\n// 默认情况下，变量或者是对象的使用，基于就近原则。\nint local_variable(){\n    int number  = 100; // 局部变量 | 本地变量  :: 称之为域符号 表示作用域\n    cout << "local::number =" << ::number << endl;// 99\n\n}\n\n//静态变量\nvoid static_local_example(){\n\n    //static : 表示静态\n    static int num{100}; //只会执行一次。\n    cout << "num ="<< num << endl;\n    num+=100;\n    cout << "num ="<< num << endl;\n}\n\nint main (){\n\n    static_local_example(); // 100 ， 200\n    static_local_example(); // 200 ， 300\n\n\n    local_variable();\n\n    cout << " main::number = " << number << endl;//99\n\n\n    {  //代码块 \n        int age = 10; \n        cout << "age =" << age << endl;//10\n    }\n    \n    return 0 ;\n}\n\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);